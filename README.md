# leetcode

 记录刷题过程中的一些值得注意的知识点和经典题

[TOC]



***

## 2020/11/06	根据数字二进制下1的数目排序

给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。请你返回排序后的数组。

```c++
示例1：

输入：arr = [0,1,2,3,4,5,6,7,8]
输出：[0,1,2,4,8,3,5,6,7]
解释：[0] 是唯一一个有 0 个 1 的数。
[1,2,4,8] 都有 1 个 1 。
[3,5,6] 有 2 个 1 。
[7] 有 3 个 1 。
按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]

示例2：

输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]
输出：[1,2,4,8,16,32,64,128,256,512,1024]
解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。
```

***

代码实现：

```c++
class Solution {
public:
    static int cal(int a) {
        int count = 0;
        while (a) {
            count += (a % 2);
            a /= 2;
        }
        return count;
    }
    
    static bool compare(int a, int b) {
        if (cal(a) > cal(b)) {
            return false;
        }
        else if (cal(a) == cal(b)) {
            return a > b ? false : true;
        }
        else {
            return true;
        }
    }
    
    vector<int> sortBybits(vector<int>& arr) {
 		sort(arr.begin(), arr.end(), conmpare);
        return arr;
    }
}
```

***

这道题本身很简单，只需要改写sort函数的比较函数重新排序就好。但是在写的过程中遇到了报错的问题`invalid use of non-static member function`

经过查询可知，在类中写比较函数时，compare需要被定义成static类型。原因在于其实我们写参数compare时，是把函数名作为实参传递给了sort函数，而sort函数内部是用一个函数指针去调用这个函数的，我们知道class普通类成员函数需要通过`对象名.compare()`来调用，而sort()函数早就定义好了，那个时候哪知道你定义的是什么对象，所以内部是直接compare()`的，那你不加static时，去让sort()直接用``compare()`当然会报错。

**顺便复习一下几个基础知识点：**

### compare和static的用法

- `compare(int a, int b)`是一个布尔类型的函数，当`a > b`，返回true时，表示数据降序排列。当`a < b`，返回true时，表示数据升序排列

- `static`的用法
  - 在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。存储在静态存储区中。全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
  - 在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。存储在静态存储区中。表示当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；
  - 在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
  - 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。
  - 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

***

## **2020/11/11**	股票问题

前两天做题做到了经典的股票问题，股票问题有好几个变种题，正好股票题都是用动态规划做，我发现自己动态规划用的还是不好，因此既当作总结，也当作练手了。

动态规划的实现步骤：

- 状态定义
- 状态转移方程
- 起始条件

***

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

 示例 1:

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**解题思路：**

- **状态定义**：设dp[i]表示第i天所取得的最大利润，然而当前的持股情况可能分为两种情况：当天持股或者当天不持股，因此可以使用一个二维数组来进行状态定义	`dp[i][0]`表示第i天不持股的情况,`dp[i][1]`表示第i天持股的情况

- **状态转移方程:**

  ```c++
  //第i天不持股可能分为两种情况，第i - 1天就不持股或者第i - 1天持股但是第i天卖出去了
  dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);	
  
  //第i天持股可能分为两种情况，第i - 1天就持股了或者之前一直都没有持股，第i天的时候买入了
  dp[i][1] = max(dp[i - 1][1], 0 - prices[i]);
  ```

- **起始条件：**第一天分为两种情况，第一天不买股票`dp[0][0] `= 0或者第一天买了股票`dp[0][1]= - prices[0]`

**代码实现：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }
        int n = prices.size();
        int dp[n + 1][2];
        dp[0][0] = 0;
        dp[0][1] = 0 - prices[0];
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], 0 - prices[i]);
        }
        return dp[n - 1][0];
    }
};
```

***

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



示例 1:

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**解题思路：**

- **状态定义**：设dp[i]表示第i天所取得的最大利润，然而当前的持股情况可能分为两种情况：当天持股或者当天不持股，因此可以使用一个二维数组来进行状态定义	`dp[i][0]`表示第i天不持股的情况,`dp[i][1]`表示第i天持股的情况

- **状态转移方程:**

  ```c++
  //第i天不持股可能分为两种情况，第i - 1天就不持股或者第i - 1天持股但是第i天卖出去了
  dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);	
  
  //第i天持股可能分为两种情况，第i - 1天就持股了或者之前卖出了，第i天的时候又买入了
  dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
  ```

- **起始条件：**第一天分为两种情况，第一天不买股票`dp[0][0] `= 0或者第一天买了股票`dp[0][1]= - prices[0]`

**代码实现：**

```c++
class Solution {
public:
    int MaxProfit(vector<int>& prices) {
        if (prices.size() == 0 || prices.size() == 1) {
            return 0;
        }
        int dp[prices.size() + 1][2];
        dp[0][0] = 0;
        dp[0][1] = 0 - prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[prices.size() - 1][0];
    }
}
```

***

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```c++
示例 1:

输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**解题思路：**

- **状态定义**：

  设dp[i]表示第i天所取得的最大利润，然而当前的持股情况可能分为两种情况：当天持股或者当天不持股，因此可以使用一个二维数组来进行状态定义	`dp[i][0]`表示第i天不持股的情况,`dp[i][1]`表示第i天持股的情况。

  本体与前两题不同得地方在于本题设置了次数限制，即最多只能购买卖出两次，因此，如果需要继续使用动态规划则需要对原本得状态定义添加条件：`dp[i][k][0],dp[i][k][1]`，k表示第i天时已经购买过得次数，注意此时定义购买时算一次。因此，相应得状态转移方程也需要变换。

- **状态转移方程:**

  ```c++
  //第i天不持股可能分为两种情况，第i - 1天就不持股或者第i - 1天持股但是第i天卖出去了,同时需要计算当k = 1和k = 2是的情况
  dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);	
  
  //第i天持股可能分为两种情况，第i - 1天就持股了或者之前卖出了，第i天的时候又买入了。
  //因为上一次已经卖出了，所以上一次是dp[i - 1][k - 1][0],因为本题按照买入的时候算做一次
  dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
  ```

- **起始条件：**第一天分为两种情况，第一天不买股票`dp[0][k][0] `= 0或者第一天买了股票`dp[0][k][1]= - prices[0]`,`k = 0,1,2`;

**代码实现：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0 || prices.size() == 1) {
            return 0;
        }
        int n = prices.size();
        int K = 3;                          //存放已经交易了几次，最多两次
        int dp[n + 1][K][2];
        for (int i = 0; i < K; i++) {
            dp[0][i][0] = 0;
            dp[0][i][1] = 0 - prices[0];
        }
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < K; j++) {
                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
                dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
            }
        }
        return dp[n - 1][K - 1][0];
    }
};
```



***

## 2020/11/18 [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

难度中等451收藏分享切换为英文接收动态反馈

在一条环路上有 *N* 个加油站，其中第 *i* 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 *i* 个加油站开往第 *i+1* 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

**说明:** 

- 如果题目有解，该答案即为唯一答案。
- 输入数组均为非空数组，且长度相同。
- 输入数组中的元素均为非负数。

**示例 1:**

```
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消
```

```c++
/**
 * 用一次遍历，遍历每个点，看是否能够绕环行驶。
 * start用于表示当前出发点
 * total表示需要消耗的总油量
 * cur表示当前加油站到下一个加油站所需要消耗的油量
 * 从第0个加油站开始计算消耗的总油量和当前需要的油量，如果当前需要的油量<0，说明无法到达下一个加油站
 * 则重置当前的cur，并将start + 1 ，重新开始计算。此时total继续叠加每一次所需要的油量。如果有一个点存在
 * 可以绕环行驶回到原点，那么total的值在全部遍历以后一定会 >= 0；
**/

class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int start = 0, total = 0, cur = 0;
        for (int i = 0; i < gas.size(); i++) {
            total += gas[i] - cost[i];
            cur += gas[i] - cost[i];
            if (cur < 0) {
                cur = 0;
                start = i + 1;
            }
        }
        return total >= 0 ? start : -1;
    }
};
```

***

## 2020/11/28 [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

一条包含字母 `A-Z` 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的**非空**字符串，请计算解码方法的总数。

题目数据保证答案肯定是一个 32 位的整数。

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```



**解题思路：**

**动态规划：**该题需要进行分类，首先进行状态定义，设`dp[i]`为`[0,i]`之间的最大译码数量。

然后进行状态转移方程的推导。这里需要明确的第一件事是，`s[i]`需要分情况讨论：

- 当`s[i]=='0'`时
  - 当`s[i-1]=='1' | s[i-1]=='2'`时，由于`'0'`无法进行译码，所以实际上`s[i-1]s[i]`是合并译码的，此时`dp[i]=dp[i-2]`
  - 又因为只有26个数，因此，不满足以上两个条件，则无解

- 当`s[i]>='1' && s[i] <= '9'`时，此时`dp[i]=dp[i-1]+dp[i-2]`。既可以`s[i-1]s[i]`合并译码`dp[i-2]`，也可以`s[i-1]s[i]`分开译码`dp[i-1]`
- 当`s[i-1]=='2' && s[i]>='1' && s[i] <= '6'`时，意味着此时数组为[21,26]，则同上`dp[i]=dp[i-1]+dp[i-2]`
- 当数组为个位数的时候，`dp[i]=dp[i-1]`

最后，起始条件`dp[0]=0`;`dp[1]=1`



**代码实现：**

```c++
class Solution {
public:
    int numDecodings(string s) {
  		if (s[0] == '0') {
            return 0;
        }   
        int pre = 1;		//前一个数的译码数量
        int cur = 1;		//存放当前数的译码数量
        for (int i = 1; i < s.size(); i++) {
            int tmp = cur;
            if (s[i] == '0') {
                if (s[i - 1] == '1' || s[i - 2] == '2') {
                    cur = pre;			//如果字符是10或者20,则合并译码，当前译码数量等于前一个数的译码数量
                }
                else {
                    return 0;
                }
            }
            else if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] >= '1' && s[i] <= '6')) {
                cur = pre + cur;			//如果字符为[11,26]不包括20，则既可以分开译码也可以合并译码，当前译码数量，等于pre+cur;
            }
            pre = tmp;						//一个循环，将当前数设置为之前数
        }
        return cur;
    }
};
```

***

## 2020/12/02 [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

统计所有小于非负整数 n 的质数的数量。

示例 1：

```
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
示例 2：

输入：n = 0
输出：0
示例 3：

输入：n = 1
输出：0
```



**解题思路：**

本题是一道简单题，但是从这道简单题中学到了一些新的算法和思想，特此记录

1. **暴力法和优化暴力法**

   判断一个数是不是质数的方法，就是看该数是否存在除1和它本身之外的因数。因此，可以从2开始，一个一个计算n是否能整除。

   然而这种暴力法用时极高，需要进行优化。

   假设`y`是`x`的一个因数，那么`x/y`也一定是`x`的因数，可以判断出，两个因数中更小的那个的区间范围一定是`[2, sqrt(x)]`，因此，时间复杂度可以降低为O（根号x）

2. **埃式筛：**这是今天学到的一个新的算法，基本原理如下：

   ![img](https://img-blog.csdnimg.cn/20181218124213973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbGx5X1pfUF9G,size_16,color_FFFFFF,t_70)

   

**代码实现：**

```c++
class Solution {
public:
    //埃式筛
    int countPrimes(int n) {
        vector<int> IsPrime(n, 1);
        int count = 0;
        for (int i = 2; i < n; i++) {
            if (IsPrime[i]) {
                count++;
                for (int j = 2 * i; j < n; j += i) {        //埃式筛法将最小的素数留下并将其相应的倍数去除
                    IsPrime[j] = 0; 
                }
            }
        }
        return count;
    }
/*
    //优化的暴力法
    bool IsPrime(int x) {
        for (int i = 2; i * i <= x; i++) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }

    int countPrimes(int n) {
        int count = 0;
        for (int i = 2; i < n; i++) {
            if (IsPrime(i)) {
                count++;
            }
        }
        return count;
    }

    //暴力法，一个数一个数的判断是否是质数
    int countPrimes(int n) {
        int count = 0;
        for (int i = 2; i < n; i++) {
            int flag = 1;
            for (int j = 2; j < i; j++) {
                if (i % j == 0) {
                    flag = 0;
                    break;
                }
            }
            if (flag) {
                count++;
            }
        }
        return count;
    }
*/
}; 
```

***

## 2020/12/05 [659. 分割数组为连续子序列](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/)

这道题其实是昨天的一道题，但是这道题搞了我很久，特此记录

给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。

如果可以完成上述分割，则返回 true ；否则，返回 false 。

```
示例 1：
输入: [1,2,3,3,4,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3
3, 4, 5

示例 2：
输入: [1,2,3,3,4,4,5,5]
输出: True
解释:
你可以分割出这样两个连续子序列 : 
1, 2, 3, 4, 5
3, 4, 5

示例 3：
输入: [1,2,3,4,4,5]
输出: False

```





**解题思路：**

这道题的几个关键点：

- 升序排列
- 连续整数
- 长度至少为3

这几个关键点分别说明了，每个子序列一定是顺序的，不存在跨越式的升序，比如3，5跳过了4。其次每个子序列必须大于等于3，意味着一旦有一个最小子序列小于3，势必返回`false`。

运用哈希表+小根堆处理这个问题。

- 以当前数作为键名。以以当前数为序列尾的序列长度尾键值，运用最小堆将序列长度由小到大存放。
- 策略：如果当前值能够与前面的值相连，则不需要重新建立新键，并将最小的长度序列pop
  - 当前值不能与已有的序列相连，则新建序列。当前数为键名的序列加一
  - 当前序列可以和已有的序列相连：
    - 从最小堆中取出最小的一个序列，将序列长度+1，并将键名替换成当前数**(注意，这个地方需要先将前一个键值删除，不然会报错)**

- 再运用一个优先队列，判断最小的子序列是否都大于等于3。



**代码实现：**

```c++
class Solution {
public:
    bool isPossible(vector<int>& nums) {
        //哈希表的键值存储每个子序列的最后一个数，最小堆存放每个子序列的长度，则每次pop的是最小的序列长度，需要至少==3；
        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> mp;
        for (auto& val : nums) {    
            if (mp.find(val) == mp.end()) {         //如果当前map中找不到相应的val，则新建一个子序列
                mp[val] = priority_queue<int, vector<int>, greater<int>> ();
            }
            if (mp.find(val - 1) != mp.end()) {     //如果找到了val，且val-1也存在map中
                int prelength = mp[val - 1].top();  //取出加入val之前的最小子序列长度
                mp[val - 1].pop();
                if (mp[val - 1].empty()) {          //删除以前数结尾为键，这一步很重要，不然会报错
                    mp.erase(val - 1);
                }
                mp[val].push(prelength + 1);         //将val加入后，将序列长度重新加入优先队列中
            }
            else {                                   //如果map中没有找到val-1，即val不能连接val-1，则需要重新建立一个序列
                mp[val].push(1);
            }
        }
        for (auto it = mp.begin(); it != mp.end(); it++) {
            priority_queue<int, vector<int>, greater<int>> queue = it -> second;
            if (queue.top() < 3) {
                return false;
            }
        }
        return true;
    }
};
```

***

## 2021/02/05	1208. 尽可能使字符串相等

​	**我胡汉三又回来了！！**

​	**忙于毕业论文没认真刷题，总结也落下了，现在有问题继续更新**

给你两个长度相同的字符串，s 和 t。

将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。

用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。

如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。

 

```
示例 1：
输入：s = "abcd", t = "bcdf", cost = 3
输出：3
解释：s 中的 "abc" 可以变为 "bcd"。开销为 3，所以最大长度为 3。

示例 2：
输入：s = "abcd", t = "cdef", cost = 3
输出：1
解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。

示例 3：
输入：s = "abcd", t = "acde", cost = 0
输出：1
解释：你无法作出任何改动，所以最大长度为 1。
```



**解题思路：**

起初看这道题的时候一直没看明白，看了半天都不知道对面在干嘛，看了别人的题解才搞懂是什么意思，原来是没看明白`maxcost`这个变量。

这道题写了一大堆，其实把`cost`数组重新列一边就明白了。这道题本质上是求`cost`数组中当前`cost`和小于`maxcost`时，存在的最长字符串长度。

<img src="https://pic.leetcode-cn.com/1612486268-iJXYou-file_1612486268430" alt="幻灯片1.JPG" style="zoom: 33%;" />

因此，本题的解题步骤可以分为以下三步：

1. 遍历`s`,`t`数组，计算`cost`值并保存到`cost`数组中
2. 设计滑动窗口，计算小于`maxcost`时的最大字符串长度
3. 输出最长字符串长度

```c++
class Solution {
public:
    int equalSubstring(string s, string t, int maxCost) {
   		if (s.size() < 1) {
            return 0;
        }     
        int n = s.size();
        vector<int> costs(n);
        for (int i = 0; i < n; i++) {
            costs[i] = abs(s[i] - t[i]);
        }
        int left = 0, right = 0;
        int sum = 0;
        int res = 0;
        while (right < n) {
            sum += costs[right];
            while (sum > maxCost) {
                sum -= costs[left];
                left++;
            }
            res = max(res, right - left + 1);
            right++;
        }
        return res;
    }
}；
```

***

### 滑动窗孔模板设计和分析

滑动窗口作为一种经典的算法，运用于各种软件编写设计中。其中TCP/IP协议中的滑动窗口模型最为知名。

**「滑动窗口」是一个默认固定大小的窗口，在一些条件触发的情况下，可能会将其大小进行修改**。

《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：**前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。**

一个滑动窗口的模板，能解决大多数的滑动窗口问题，伪代码如下：

```c++
def findSubArray(nums):
	n = len(nums);					//字符串/数组长度
	left = 0, right = 0;			//双指针表示当前的窗口区间
	sum = 0;						//统计 子数组/子区间 是否有效，或者改成 求和/计数
	res = 0;						//保存满足题目要求的 字符串/数组长度
	while (right < n)				//当窗口的右边界没有遍历到数组尾
        sum += nums[right];			//增加当前右指针的 数字/字符 的 求和/计数
		while 区间[left, right]不符合题意	//不断右移左指针，直到找到一个合适的值
            sum -= nums[left];			//移动左指针前，需要将sum减去窗口左边界的数值
			left++;						//缩小窗口
		//当while结束时，寻找到一个合适的sum值
		res = max(res, right - left + 1);	//更新结果
		right++;						//像右扩张窗口
	return res;
```

滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。

模板的整体思想是：

		1. 定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；
		2. 第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和/计数；
		3. 第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和/计数；
		4. 在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求最大的区间长度，因此更新 res 为 max(res, 当前区间的长度) 。
		5. right 指针每次向右移动一步，开始探索新的区间。
模板中的 sums 需要根据题目意思具体去修改，本题是求和题目因此把sums 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sums 。

另外一个需要根据题目去修改的是内层 while 循环的判断条件，即： 区间[left, right]不符合题意 。对于本题而言，就是该区内的和 sums 超过了 `maxCost `。

***

### 滑动窗口与双指针的区别

如果「滑动窗口」和「双指针」没有啥区别，可以互相替换，那么我们显然不会为一个笔试和面试中常考的知识点进行冗余的命名。一些没有命中要害的文章可能是这样分析的：

- 「滑动窗口」是固定大小的，「双指针」是不固定大小的；

- 「滑动窗口」一定是同向移动的，「双指针」可以相向移动。

***

## 2021/02/06	1423.可获得的最大数

几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。

每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。

你的点数就是你拿到手中的所有卡牌的点数之和。

给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。

```c++
示例 1：
输入：cardPoints = [1,2,3,4,5,6,1], k = 3
输出：12
解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。

示例 2：
输入：cardPoints = [2,2,2], k = 2
输出：4
解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。

示例 3：
输入：cardPoints = [9,7,7,9,7,7,9], k = 7
输出：55
解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。

示例 4：
输入：cardPoints = [1,1000,1], k = 1
输出：1
解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 

示例 5：
输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3
输出：202
```



**解题思路：**

该题可以使用两种滑动窗口的方法。

- 第一种，将窗口大小设置为`cardpoints.size() - k`，从左向右移动，计算剩下的值大小，选择最大的值
- 第二种，窗口逆向移动，将窗口大小设置为`k`，从数组头逆向移动，计算窗口中的最大值。

```c++
/***********
 * 逆向滑动窗口
 * 可以说是很巧妙了
************/

class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int len = cardPoints.size();
        int sum = 0;
        /* 先计算前k个值得总和 */
        for (int i = 0; i < k; i++) {
            sum += cardPoints[i];
        }
        /* 保存当前值 */
        int res = sum;
        /* 逆向滑动窗口，大小为k，寻找逆向窗口中的最大值 */
        for (int i = 0; i < k; i++) {
            sum += cardPoints[len - 1 - i] - cardPoints[k - 1 - i];
            res = max(res, sum);
        }
        return res;
    }
};
```

***

